Time Complexity: O(n²)
Space Complexity: O(n) 
"""
Time Complexity
DFS to find connected components

Outer loop: for i in range(n) → O(n)

DFS call visits each node once, and inside DFS we check all n possible neighbors (for j in range(len(graph))) because the graph is given as an adjacency matrix.

So DFS over all components is O(n²) total (not O(V+E) here because we scan all neighbors in each DFS step).

Count group sizes (groups)

Loop over colors → O(n)

Count infections (infect)

Loop over initial → O(k), where k = len(initial) ≤ n

Find answer

Loop over initial again → O(k)

Overall:

Dominated by DFS step → O(n²)

Space Complexity
colors: O(n)

groups & infect: O(n) each in worst case (n disconnected nodes)

Recursion stack in DFS: O(n) in worst case (fully connected or chain)

Input graph: Already given as O(n²), but not counted toward extra space complexity.

Overall extra space: O(n)


"""


class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        """
        1. do dfs to find number of groups ot there which are not conneted
            >do dfs on each number of if its visted dont else inc grpnumber then do bfs
        2.now you got number of groups 
            note this might or might not be equal to intial ..actually this not valid .. all intitla might be same in diffret gtoups
        3.now we should check if each number belong to which group
            this can be done we have n group[0],hroup[1]... so 
            this can be doine in step 1 
        4. number of affected nodes in each group and we also need count of nodes in each group
            1.if  more than    1 we cnanot minize spread
            2.if <=1 its number of nodes
        
        
        
        """
        
        colors=[-1  for _ in range(len(graph))] # to check number of infected  node s in asub non conedced graph
        cl=0
        n=len(graph)
        def dfs(graph,node,cl):
            #base
            if colors[node]!=-1:return
            #logic

            colors[node]=cl
            for j in range(len(graph)):
                if node==j:continue
                if graph[node][j]==1:
                    dfs(graph,j,cl)


        for i in range(n):
             #to get number of groups
            if colors[i]==-1:
                dfs(graph,i,cl) # in dfs update colors arraty
                cl+=1
        #now we have number of groups 
        groups=[0 for _ in range(cl)] #number of nodes  in each group
        infect=[0 for _ in range(cl)] #number of infected nodes in each group beacuse of 1 or more nodes
        for i in colors:
            if i!=-1:
                groups[i]+=1
        # for i in colors:
        #     groups[i]+=1
        for i in initial:
            infect[colors[i]]+=1
         
        ans=-1  
        for z in initial:
            ii=colors[z]
            if infect[ii]!=1:continue
            if ans==-1:
                ans=z
            elif groups[ii]>groups[colors[ans]]:
                
                ans=z
            elif groups[ii]==groups[colors[ans]] and z< ans:
                
                ans=z
        

        if ans==-1:
            ans=float('inf')
            for node in initial:
               
                
                ans=min(ans,node)
        return ans



        
        



        
       

